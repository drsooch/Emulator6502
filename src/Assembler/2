-- | Module for parsing 6502 Assembly

module Assembler.Parser
    ( pDirective
    , pDirective'
    , pEndDirective
    , parseFile
    , AsmStatement(..)
    , AsmNumeric(..)
    , AsmDirectiveType(..)
    , asmStatement
    ) where

import           Data.Char                      ( isAlpha )
import           Data.Functor                   ( ($>) )
import           Data.Text                      ( Text
                                                , pack
                                                )
import qualified Data.Text.IO                  as TIO
import           Data.Void                      ( Void )
import           Text.Megaparsec                ( (<?>)
                                                , Parsec
                                                , between
                                                , choice
                                                , empty
                                                , many
                                                , manyTill
                                                , notFollowedBy
                                                , optional
                                                , parseTest
                                                , takeWhileP
                                                , try
                                                )
import qualified Text.Megaparsec.Char          as C
import qualified Text.Megaparsec.Char.Lexer    as L
import           Types                          ( OpName(..) )

type AssemblerParser a = Parsec Void Text a

data AsmStatement = StmtEndLabel
                  | StmtDirective AsmDirectiveType
                  | StmtCodeLabel Text
                  | StmtDefineLabel Text AsmNumeric
                  | StmtProgramCounter (Maybe Int)
                  | StmtRegisterName AsmRegisterName
                  | StmtOpCode OpName (Maybe AsmAddressType)
                  deriving (Show, Eq)

data AsmRegisterName = AsmA
                     | AsmX
                     | AsmY
                     deriving (Eq, Show)

data AsmDirectiveType = DtByte AsmNumeric
                      | DtDByte AsmNumeric
                      | DtWord AsmNumeric
                      | DtBlock AsmNumeric
                      | DtEqu AsmNumeric
                      | DtText Text
                      deriving (Eq, Show)

data AsmNumeric = DecimalLiteral Int
                | HexLiteral Int
                | BinaryLiteral Int
                | BlockSize Int
                | HexAddress Int
                deriving (Eq, Show)

-- NOTE: AsmImplicit is the result when StmtOpCode has a Nothing Value
-- We can't really parse anything if we don't know what OpCode we get
-- (not entirely true theres probably some functions that we can pass forward the OpCode)
-- Either way in the current implementation we don't actually use AsmImplicit
data AsmAddressType = AsmImmediate AsmNumeric
                    | AsmZeroPage AsmNumeric (Maybe AsmRegisterName)
                    | AsmAbsolute AsmNumeric (Maybe AsmRegisterName)
                    | AsmIndirect AsmNumeric (Maybe AsmRegisterName)
                    | AsmRelative
                    | AsmAccumulator
                    -- AsmImplicit
                    deriving (Eq, Show)

parseFile :: IO ()
parseFile = do
    contents <- TIO.readFile "test/directive.asm"
    print contents
    parseTest (asmStatement >> pEndDirective) contents
    -- let result = runParser (many ignore <* pEndDirective <* eof) "Test File" contents
    -- print result

asmStatement :: AssemblerParser AsmStatement
asmStatement = choice [try pOpCode, try pDirective, try pDefineLabel, pLabel]

whiteSpace :: AssemblerParser ()
whiteSpace = L.space C.space1 (L.skipLineComment ";") empty

lexeme :: AssemblerParser a -> AssemblerParser a
lexeme = L.lexeme whiteSpace

symbol :: Text -> AssemblerParser Text
symbol = L.symbol whiteSpace

comma :: AssemblerParser ()
comma = symbol "," $> ()

colon :: AssemblerParser ()
colon = symbol ":" $> ()

directiveStart :: AssemblerParser ()
directiveStart = C.char '.' $> ()

equals :: AssemblerParser ()
equals = symbol "=" $> ()

parens :: AssemblerParser a -> AssemblerParser a
parens = between (symbol "(") (symbol ")")

hexIdent :: AssemblerParser ()
hexIdent = symbol "$" $> ()

binIdent :: AssemblerParser ()
binIdent = symbol "%" $> ()

literalIdent :: AssemblerParser ()
literalIdent = symbol "#" $> ()

stringLiteral :: AssemblerParser Text
stringLiteral = pack <$> C.char '\"' *> manyTill L.charLiteral (C.char '\"')

{- NUMERICS -}
pHexLiteral :: AssemblerParser AsmNumeric
pHexLiteral = HexLiteral <$> lexeme (literalIdent >> hexIdent >> L.hexadecimal)

pBinaryLiteral :: AssemblerParser AsmNumeric
pBinaryLiteral = BinaryLiteral <$> lexeme (literalIdent >> binIdent >> L.binary)

pDecimalLiteral :: AssemblerParser AsmNumeric
pDecimalLiteral = DecimalLiteral <$> lexeme (literalIdent >> L.decimal)

pHexAddress :: AssemblerParser AsmNumeric
pHexAddress = HexAddress <$> lexeme (hexIdent >> L.hexadecimal)

pNumeric :: AssemblerParser AsmNumeric
pNumeric =
    choice [try pHexLiteral, try pBinaryLiteral, try pDecimalLiteral, pHexAddress] <?> "Numeric"

pDirective :: AssemblerParser AsmStatement
pDirective = StmtDirective <$> undefined

pDirective' :: AssemblerParser AsmStatement
pDirective' =
    StmtDirective
        <$> choice
                [ DtByte <$ C.string' "BYTE" <*> pNumeric
                , DtDByte <$ C.string' "DBYTE" <*> pNumeric
                , DtWord <$ C.string' "WORD" <*> pNumeric
                , DtBlock <$ C.string' "BLOCK" <*> pNumeric
                , DtEqu <$ C.string' "EQU" <*> pNumeric
                , DtText <$ C.string' "TEXT" <*> stringLiteral
                ]
        <?> "Directive"

pEndDirective :: AssemblerParser AsmStatement
pEndDirective = StmtEndLabel <$ lexeme (directiveStart >> C.string' "END")

-- TODO: Implement 6 Character Limit on Labels as defined by the resource book.
pLabel :: AssemblerParser AsmStatement
pLabel = StmtCodeLabel
    <$> lexeme (takeWhileP (Just "Code Label") isAlpha <* optional colon <* notFollowedBy "=")

-- TODO: See `pLabel`
pDefineLabel :: AssemblerParser AsmStatement
pDefineLabel =
    StmtDefineLabel <$> lexeme (takeWhileP (Just "Define Label") isAlpha <* equals) <*> pNumeric

pARegister :: AssemblerParser AsmRegisterName
pARegister = AsmA <$ lexeme (C.string' "A")

pXRegister :: AssemblerParser AsmRegisterName
pXRegister = AsmX <$ lexeme (C.string' "X")

pYRegister :: AssemblerParser AsmRegisterName
pYRegister = AsmY <$ lexeme (C.string' "Y")

-- Parse any register name
pRegister :: AssemblerParser AsmRegisterName
pRegister = choice [pARegister, pXRegister, pYRegister] <?> "Register"

-- parse just X and Y for use with an instruction address
pAddressRegister :: AssemblerParser AsmRegisterName
pAddressRegister = choice [pXRegister, pYRegister] <?> "Address Register"

pAddress :: AssemblerParser AsmAddressType
pAddress =
    choice
            [ AsmImmediate <$> pNumeric
            , AsmAccumulator <$ pARegister
            , AsmAbsolute <$> pHexAddress <*> optional (comma >> pAddressRegister)
            --, AsmZeroPage <$> pHexByte <*> optional (comma >> pAddressRegister)
            , pIndirect
            , pRelative
            ]
        <?> "AddressType"

pIndirect :: AssemblerParser AsmAddressType
pIndirect = choice [pIndirectX, pIndirectY, pIndirect']

-- should be a memory address with no register
pIndirect' :: AssemblerParser AsmAddressType
pIndirect' = flip AsmIndirect Nothing <$> parens pNumeric

pIndirectX :: AssemblerParser AsmAddressType
pIndirectX = parens (pNumeric >>= \num -> comma >> AsmIndirect num . Just <$> pAddressRegister)

pIndirectY :: AssemblerParser AsmAddressType
pIndirectY = AsmIndirect <$> parens pNumeric <*> (comma >> Just <$> pAddressRegister)

-- FIXME
pRelative :: AssemblerParser AsmAddressType
pRelative = pure AsmRelative

pOpCode :: AssemblerParser AsmStatement
pOpCode = StmtOpCode <$> lexeme pOpCode' <*> optional pAddress

pOpCode' :: AssemblerParser OpName
pOpCode' = choice [ADC <$ C.string' "ADC"]
